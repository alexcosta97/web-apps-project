\chapter{Technical Report}

GitHub repository: \texttt{https://github.com/alexcosta97/web-apps-project}

For this project we used ASP.NET Core 2 and an SQLite3 database. This is
interacted with the Entity Framework. We also opted for a code-first approach as
 it was the most intuitive to add user authentication to.

For our user authentication system we used ASP.NET Core Identity. With this
system we were able to create a unified user database and add roles to the
registered users. These roles were then used to restrict access to specific
methods - for example guests can only get the route index and details page,
while managers and admins can create, edit and delete routes. If guests try to
access these pages they will get redirected to the login page. Normal users will
receive an $Unauthorised$ error.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{guest-unauth}
  \caption{Guest accessing $/Routes/Edit/1$, redirected to login page}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{user-unauth}
  \caption{User accessing $/Routes/Edit/1$ showing unauthorised error}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{manager-unauth}
  \caption{Manager accessing $/Routes/Edit/1$ and getting the edit page displayed}
\end{figure}

\clearpage
Other functions of the site, such as favourites and addresses are also restricted
to those associated with the currently logged in user.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{addresses-admin}
  \caption{User account with an address created by the user}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{addresses-manager}
  \caption{Another user account with no addresses displayed}
\end{figure}

In order to allow the system administrator manage users and roles in the
application, we had to implement our own custom controllers and views.
It made for a better customized and saved also the amount of scaffolded code
we had to review.

The rest of the views and controllers were scaffolded after we had built the
models based on our initial class diagram. After scaffolding the controllers
and views, we had to test the components that were built to make sure that
the relationships between the elements were defined like we wanted them to
and that the data that we wanted to be displayed was doing so correctly.

For this project, we spent most of the time around the authorization processes,
making sure that only the right users had access to the right data and functionality,
but also around customizing the views and controllers so that names instead of IDs
were displayed to the users, when an element from a relationship had to be selected
(for example the staff member that will be the driver for a route).
